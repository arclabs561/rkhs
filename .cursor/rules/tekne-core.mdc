---
description: PRIMARY INVARIANTS for the Tekne Stack (L0-L6). This is the single source of truth for architecture and safety.
globs: ["**/*.rs", "**/Cargo.toml"]
alwaysApply: true
---

# Tekne Core Invariants (L0-L6)

## 0.5 Dev Workspace Reality (this folder is not a repo)

This Cursor workspace (the folder you opened in Cursor) is a **super-workspace** directory:

- **Not a git repo**: do not assume `git` operations make sense at the workspace root.
- **Many independent projects live side-by-side**: most subdirectories are their own repos (or archives), with their own history and tooling.
- **One root Cargo workspace exists**: `Cargo.toml` at the root defines a *virtual* Rust workspace that includes a curated subset of crates across subdirectories.
- **Cargo.lock is not present at the root**: dependency stability comes from per-crate `Cargo.lock` files (where used) and pinned workspace dependency versions in the root `Cargo.toml`.

Implication: when reasoning about “the project”, be explicit about *which* layer you mean:
\[
\text{root dev folder} \;\supset\; \text{root Cargo workspace members} \;\supset\; \text{Tekne stack subset (one organizing view)}.
\]

## 0. The Principle of Economy of Thought
**Goal**: Reduce the reasoning required to understand the system.
*   **Framing over Computation**: Time spent finding the right mathematical framing (e.g. Invariants) beats time spent debugging executions.
*   **Separation of Concerns**: 
    *   **Efficiency** is settled in L0 (Iron).
    *   **Correctness** is settled in L1 (Logic).
    *   **Orchestration** is settled in L6 (Mesh).
*   **The Five-Line Rule**: If a core logic argument or function body exceeds ~5 lines, reconsider the framing.

## 1. The Layering Invariant (DAG Hard-Stop)
The Tekne Stack is a Directed Acyclic Graph (DAG). **No lower layer may depend on a higher layer.**

| Layer | Name | Domain | Responsibility |
| :--- | :--- | :--- | :--- |
| **L0** | **Iron** | Hardware/SIMD | Raw performance, vector similarity ($Cosine$, $L_2$). |
| **L1** | **Logic** | Math Primitives | Scalar measures: Entropy, Divergences ($KL$, $JS$). |
| **L2** | **Algos** | Composite | Differentiable sorting, optimal transport, kernels. |
| **L3** | **Structures** | Aggregators | ANN Indices (`jin`), Hierarchy/aggregation (`tier`), Graph core (`lattix`). |
| **L4** | **Embeddings** | Representations | Geometric boxes (`subsume`), Statistical mirror (`weigh`). |
| **L5** | **Domain** | Systems/NLP/IR | NER/Coref (`anno`), Retrieval (`cerno`), Knowledge Graphs (`webs`). |
| **L6** | **Orch** | Multi-Agent/Mesh | Retrieval/pipeline (`hop`), coordination substrate (`hypha`). |

*   **Private Gravity**: If a higher-level system implements reusable logic, push it *down* to L0-L2.
*   **Enforcement**: Prefer automated checks, but don’t assume a verifier exists.
    If enforcement tooling is missing, treat the root `Cargo.toml` membership list as the source of truth.

## 1.5 Multiple “Virtual Workspaces” Can Coexist

`tekne` is one coherent naming/stack view used by the root Cargo workspace, but it is not the only possible organizing principle.

- It’s acceptable to have other coherent sub-ecosystems (e.g., “Scholar stack”, “Infra ops”, editor plugins) living in the same dev directory.
- Do not force everything into Tekne if the dependency DAG / semantics don’t fit.

## 1.25 Three Parallel DAGs (Math/System vs Agents vs Governance)

The “Tekne stack” (L0–L6) is a **math/system DAG**. Agent/tooling and governance are **different axes**.

- **Math/System DAG**: operators, representations, and systems (e.g. `innr → logp → fynch → ... → anno/cerno/webs`).
- **Agents/Tooling DAG**: agent contract engine + orchestration apps (e.g. `axi → bop`, which then *uses* the math/system crates).
- **Governance DAG**: constraints/policy/oversight that can apply to both agents and systems, without being “higher math”.

This avoids category errors like “`axi` should be L1”: agent contracts are not math primitives.

### Why Tekne is “special”

Tekne is special in one sense: it is the **reusable substrate DAG**.

- If something is in Tekne, it should be *plausibly reusable* outside a single application.
- Therefore Tekne is the place where we are strictest about:
  - dependency direction (no higher → lower)
  - Unicode correctness at boundaries (character offsets)
  - stability of core types and invariants

Agents and Governance can be equally rigorous, but they are *different* partial orders.

### Agent/Tooling Tree (A0–A3)

Use this when you want a *different* partial order than Tekne’s L0–L6:

| Level | Name | Responsibility | Examples |
| :--- | :--- | :--- | :--- |
| **A0** | **Contracts** | Typed tool contracts, schema/repair, run traces | `axi` |
| **A1** | **Adapters** | Providers/transports (LLM, MCP, storage) | (often lives inside `axi`/apps initially) |
| **A2** | **Orchestration Apps** | The runnable agent application layer | `bop` |
| **A3** | **Operations** | Deployment, cost, monitoring | (repo-specific) |

### Governance Tree (G0–G5)

Governance is its own axis (not “L7–L12 of Tekne”):

| Level | Name | Responsibility | Repo |
| :--- | :--- | :--- | :--- |
| **G0** | **Adjudication** | deciding / evaluating / ruling | `law` |
| **G1** | **Steering** | policy + strategy control | `helm` |
| **G2** | **Equilibrium** | constraints / balance / alignment | `equi` |
| **G3** | **Interface** | representation boundaries / signaling | `sign` |
| **G4** | **Federation** | multi-party coordination contracts | `liga` |
| **G5** | **Telos** | goals/purpose/intention | `telic` |

### Cross-axis dependency rules (compile-time vs “gates”)

**Compile-time dependencies (Cargo `dependencies`)**:

- **Allowed**:
  - Agents → Tekne (agents can use substrate)
  - Governance → Tekne (governance can use substrate for scoring/metrics/types)
  - Apps (A2) → Governance (apps may call adjudicators/steering code)
- **Forbidden by default**:
  - Tekne → Agents
  - Tekne → Governance
  - Governance → Agents (especially Governance → A2 apps)

**Why**: if Tekne depends on Agents/Governance, the substrate becomes “application-shaped” and stops being substrate.

**Governance should often be a gate, not a dependency**:

- Prefer governance as *inputs/outputs* and pipeline checks:
  - plan/request → policy decision
  - run trace → evaluation/audit
- Avoid “sprinkling governance imports everywhere” as a cross-cutting compile-time dependency, which tends to reintroduce cycles and coupling.

## 2. The Naming Invariant (Structure > Style)

**Naming Strategy**: Names should make the *structure* easier to see.

\[
\text{good name} \;\approx\; \text{a cheap index into the right invariants.}
\]

### Primary Preference: Structural Resonance

- Prefer names that align with the *true symmetry* of the object:
  - distance / similarity / norm / kernel / transport / rank / conformal / graph / lattice / contract / covenant / ledger
- Prefer names that let readers guess the constraints:
  - e.g. “rank fusion” vs “rerank” vs “retrieve” are distinct operators in a pipeline; names should preserve that.
- Cross-language is encouraged when it improves precision (sometimes the original term is the most exact handle).

### Secondary Preference: Etymology (cross-cultural only when helpful)

- Culture is not the goal; *precision* is.
- Use Sanskrit/Arabic/Old Norse/etc. when it carries the exact nuance for governance or agency concepts.
- Use Latin/Greek/English when it better matches the mathematical framing.

### Ecosystem/Prefix Coherence (important)

- If a set of crates is meant to be used together, prefer a shared prefix.
  - IR stack: prefer `cerno-*` as the canonical prefix (retrieve/fuse/rerank/eval/train + facade `cerno`).
  - Text chunking: prefer `slabs` as canonical (avoid dual naming like `slabs` vs `slabs`).

### crates.io Policy (mandatory, explicit)

Always check crates.io **before** selecting a name (don’t guess).

- If a name is **taken** on crates.io (HTTP 200), treat it as **unavailable** unless:
  - the crate is permanently `publish = false`, and
  - we accept that the name is *internal-only* (no future publish path).

This prevents “pretty internal names” that block publication later.

### Consistency Rule: one concept, one name

- Avoid “ghost prior names” lingering in code/docs (e.g., `colligo` remnants inside `hop`).
- Avoid having directory name, package name, and crate name drift.
  - If we keep an old directory during migration, document it and fix it quickly.

## 3. The Meta-ND Invariant (Multi-Dimensional Metadata)
**Goal**: Unified handling of high-dimensional metadata and structures.
*   **Dimensional Rigor**: Systems dealing with N-dimensional data (e.g., `subsume` boxes, `innr` vectors) must explicitly track and leverage metadata dimensions.
*   **Subsumption Theory**: Use formal subsumption/entailment theory to manage metadata hierarchies across the stack.
*   **Representation**: Metadata should be treated as a first-class N-dimensional object, not a flat bag of tags.

## 4. Type Hierarchy & Invariants
*   **Canonical Flows**: Signal (Detection) → Track (Coreference) → Identity (Linking).
*   **Numerical Stability**: Use `NORM_EPSILON` ($10^{-9}$) for zero-norm handling.
*   **Algebraic Closure**: Intersection operations (e.g. in L4) must return the same type.

## 3. Engineering Rigor
*   **Unicode**: ALWAYS use character offsets, NEVER byte offsets for text slicing.
*   **SIMD**: Prefer `innr` for vector operations with automatic runtime dispatch.
*   **Fast Math**: Use reciprocal square root ($rsqrt$) + Newton-Raphson for throughput.
*   **Math**: Cite foundational papers (TAOCP style).

## 4. Documentation vs. Process Logs
*   **Chat for Process**: Do not write temporary markdown files for progress. Reply in chat.
*   **Lecture Notes**: Review `docs/lectures/*.md` to pick up stack-wide habits.
*   **Visual Rigor**: Visualizations must use real data from actual execution. fit distributions.

## 4.5 Memory Recall Discipline (Cursor history is data)

When intent or prior decisions matter (renames, merges, “publish vs private”, repo cleanup), **do not guess**.
Treat prior chat + rule history as a dataset and re-derive intent from it.

- **Preferred**: use `iksh` to inspect Cursor’s DB-backed chat history and rule memory:
  - list conversation ids: `cargo run -p iksh -- chats --limit N`
  - list with previews (recommended): `cargo run -p iksh -- chats --limit N --meta --format text --preview-chars 160`
  - list as JSON (for tooling): `cargo run -p iksh -- chats --limit N --format json --preview-chars 160`
  - reconstruct a conversation: `cargo run -p iksh -- convo <conversation-uuid>`
  - search for keywords: `cargo run -p iksh -- db-search-values <needle> --limit N`
- **Fallback**: consult the saved agent transcript file(s) when the DB doesn’t contain what we need.

Goal: minimize “phantom intent” errors by making recall a first-class step.

## 5. Repository & Tool Safety
*   **Isolation**: Never create a new repo inside another repo.
*   **Timeout Handling**: If a tool call fails/times out, narrow the scope. Do not repeat.
*   **Local Resolution**: Use `[patch.crates-io]` in root for development speed.

## 6. Git Discipline (Staging)

Default to explicit staging (e.g. `git add <paths>`). Avoid `git add -A` unless the user explicitly requests “stage everything”.
